#include "route.h"
#include "lib_record.h"




/*************************************************建邻接表********************************************/
/*根据topo产生邻接表*/
void createOG(OrGraph *G, char *topo[5000],int edge_num, bool isReverse){
	int val[4];
	//int j=0;
	int nv=0;
	for(int i=0;i<4;i++)
	{
		val[i]=-1;//初始化数组，用数组记录分割，val[0]为序号，val[1]为源点，val[2]为终点，val[3]为代价。
	}
	//int vex;
	ArcNode *p,*q;
	char *tmp;
	char sep[]=",";
	bool isHaveVex[MAX_VERTEX];
	memset(isHaveVex,0,sizeof(isHaveVex));
	/*for(int i=0;i<MAX_VERTEX;i++)
	{
		isHaveVex[i]=false;
	}*/
	for(int i=0; i<edge_num; i++)
	{
		tmp=strdup(topo[i]);
		val[0]=atoi(strsep(&tmp,sep));
		val[1]=atoi(strsep(&tmp,sep));
		val[2]=atoi(strsep(&tmp,sep));
		val[3]=atoi(tmp);
		p=(ArcNode *)malloc(sizeof(ArcNode));
		p->arcId=val[0];
		if(isReverse)
		{
			p->tailVex=val[2];
			p->headVex=val[1];//逆向连接构建逆邻接表，headVex弧的头节点，val[1]表示源节点，val[2]表示终点
			
		}
		else
		{
			p->tailVex=val[1];
			p->headVex=val[2];//正向连接，构建邻接表
			
		}
		
		//printf("ss%d\n",val[1]);
		p->cost=val[3];
		//p->hlink=NULL;
		p->nextLink=NULL;

		++G->clist[p->tailVex].outDegree;
		++G->clist[p->headVex].inDegree;
		
		if(!isHaveVex[p->headVex])
		{
			isHaveVex[p->headVex]=true;
			++nv;
		}
		if(!isHaveVex[p->tailVex])
		{
			isHaveVex[p->tailVex]=true;
			//G->clist[val[1]].firstLink=p;//不能这样因为有时，这个点计数了，但是没有链接，顶点无链接不一定无计数，所以可能导至有些点无链接
			++nv;
		}
		if(G->clist[p->tailVex].firstLink==NULL)
		{
			G->clist[p->tailVex].firstLink=p;
			//++G->clist[p->tailVex].outDegree;
			//++j;
		}
		
		else
		{ 
			q=G->clist[p->tailVex].firstLink;
			while(q->nextLink)
			{
				q=q->nextLink;
			}
			q->nextLink=p;
		}
			//先建立同尾的弧,相于建立邻接表
			//先建立同尾的弧，即从这个顶点出去的弧,即邻接表
	}
	//G->vexNum=j;
	G->vexNum=nv;
	G->arcNum=edge_num;
	//printf("建立邻接表ok%d个点,\n",nv);
}
/*******************************************************************************************************/

/*******************************************解析命令字符串********************************************/
/***解析demand字符串为start_end以及必经点个点和相应的点***/
void explain_demand(int post[3],int unavoid[],char *demand){
	char sep1[]=",";
	char sep2[]="|";
	post[0]=atoi(strsep(&demand,sep1));//start point
	post[1]=atoi(strsep(&demand,sep1));//end point
	int i=0;
	while(demand)
	{
	   unavoid[i++]=atoi(strsep(&demand,sep2));
	};
	post[2]=i;//unavoid point number 数组的下标加1为必经点个数。
}
/*******************************************************************************************************/

/********************************建立最小堆，堆调整，出堆，判断堆是否为空等***************************/
struct MinHeapNode* newMinHeapNode(int v, int dist) {
	struct MinHeapNode* minHeapNode = (struct MinHeapNode*) malloc(
			sizeof(struct MinHeapNode));
	minHeapNode->v = v;
	minHeapNode->dist = dist;
	return minHeapNode;
}
// A utility function to create a Min Heap
struct MinHeap* createMinHeap(int capacity){
	struct MinHeap* minHeap = (struct MinHeap*) malloc(sizeof(struct MinHeap));
	minHeap->pos = (int *) malloc(capacity * sizeof(int));
	minHeap->size = 0;
	minHeap->capacity = capacity;
	minHeap->array = (struct MinHeapNode**) malloc(
			capacity * sizeof(struct MinHeapNode*));
	return minHeap;
}
// 交换两个最小堆的节点
void swapMinHeapNode(struct MinHeapNode** a, struct MinHeapNode** b) {
	struct MinHeapNode* t = *a;
	*a = *b;
	*b = t;
}
//在位置 idx 调整堆，初始堆要调整为小顶堆
void minHeapify(struct MinHeap* minHeap, int idx) {
	int smallest, left, right;
	smallest = idx;
	left = 2 * idx + 1;
	right = 2 * idx + 2;

	if (left < minHeap->size&& minHeap->array[left]->dist < minHeap->array[smallest]->dist)
		smallest = left;

	if (right < minHeap->size&& minHeap->array[right]->dist < minHeap->array[smallest]->dist)
		smallest = right;

	if (smallest != idx) {
		// 需要交换的节点
		MinHeapNode *smallestNode = minHeap->array[smallest];
		MinHeapNode *idxNode = minHeap->array[idx];

		//交换下标
		minHeap->pos[smallestNode->v] = idx;
		minHeap->pos[idxNode->v] = smallest;

		//交换节点
		swapMinHeapNode(&minHeap->array[smallest], &minHeap->array[idx]);

		minHeapify(minHeap, smallest);
	}
}
// 推是否为空
int isEmpty(struct MinHeap* minHeap) {
	return minHeap->size == 0;
}
// 弹出堆顶的节点(即最小的节点)
struct MinHeapNode* extractMin(struct MinHeap* minHeap) {
	if (isEmpty(minHeap))
		return NULL;

	struct MinHeapNode* root = minHeap->array[0];

	struct MinHeapNode* lastNode = minHeap->array[minHeap->size - 1];
	minHeap->array[0] = lastNode;

	// 更新下标
	minHeap->pos[root->v] = minHeap->size - 1;
	minHeap->pos[lastNode->v] = 0;

	// 记得减少堆的大小
	--minHeap->size;
	minHeapify(minHeap, 0);
	return root;
}
// 当节点v的距离更新后(变小了)调整堆
void decreaseKey(struct MinHeap* minHeap, int v, int dist) {
	//获取节点 v 在 堆中的下标
	int i = minHeap->pos[v];

	minHeap->array[i]->dist = dist;

	// 因为是变小了，自下向上调整堆即可。 O(Logn)
	//printf("_______1___位置为%d\n",i);
	while (i && minHeap->array[i]->dist < minHeap->array[(i - 1) / 2]->dist) {
		minHeap->pos[minHeap->array[i]->v] = (i - 1) / 2;
		minHeap->pos[minHeap->array[(i - 1) / 2]->v] = i;
		//printf("____2____位置为%d\n",i);
		swapMinHeapNode(&minHeap->array[i], &minHeap->array[(i - 1) / 2]);
		//printf("____2____位置为%d\n",(i-1)/2);
		i = (i - 1) / 2;
	}
}
// 判断节点v是否在堆中
bool isInMinHeap(struct MinHeap *minHeap, int v) {
	//printf("kankan1:---------------k\n");
	if (minHeap->pos[v] < minHeap->size)
		return true;
	return false;
}
void printHeapNode(MinHeapNode *p,int n){
	for(int i=0;i<n;i++)
	{
		printf("%d\t\t%d\t\t%d\n",i,p[i].v,p[i].dist);
	}
}
/*******************************************************************************************************/

/***************************************测试*******最短路径基本算法*****************************************/
// 打印结果
void printVal(int arr[],int n,char *p)
{
	for(int i=0;i<n;i++)
	{
		printf("%s[%d]=%d  ",p,i,arr[i]);
	}
	//printf("\n");
}
void printValBool(bool arr[],int n,char *p)
{
	for(int i=0;i<n;i++)
	{
		printf("%s[%d]=%d  ",p,i,arr[i]);
	}
	//printf("\n");
}
/*void printArr(int dist[], int n) {
	printf("Vertex   Distance from Source\n");
	int i;	

	for (i = 0; i < n; ++i)
		printf("%d \t\t %d\n", i, dist[i]);
}*/
//计算给定初始点到其它点的最短距离

void dijkstra(OrGraph *G,int src,int *dist,int *path){
	//最小优先队列，数组的方式,以后换feib堆。
	int vNum=G->vexNum;
	//printf("vNum=%d\n",vNum);
	//int dist[vNum];
	
	MinHeap* minHeap=createMinHeap(vNum);
	//初始化堆包含所有的顶点
	int i;
	for(i=0;i<vNum;++i)
	{
		dist[i]=MYINF;
		minHeap->array[i]=newMinHeapNode(i,dist[i]);
		minHeap->pos[i]=i;
		path[i]=-1;
	}
	// 把 源点 src 的距离设置为0，第一个取出的点即为源点
	//minHeap->array[src] = newMinHeapNode(src, dist[src]);
	//minHeap->pos[src] = src;
	dist[src] = 0;
	path[src]=src;//自己的前驱为自己
	decreaseKey(minHeap, src, dist[src]);//因为源点到其它节点的路径是不知道的所以不用调整堆。

	minHeap->size = vNum;

	// 这个循环中，minHeap包含的是所有未在SPT中的顶点
	while (!isEmpty(minHeap)) {
		// 取得堆顶节点，即最小距离的顶点
		MinHeapNode* minHeapNode = extractMin(minHeap);
		int u = minHeapNode->v;

		// 只需要遍历和u相邻的顶点进行更新
		ArcNode* pCrawl = G->clist[u].firstLink;
		while (pCrawl != NULL)
		{

			int v = pCrawl->headVex;
			// 松弛操作，更新距离
			if (isInMinHeap(minHeap, v) && dist[u] != MYINF && pCrawl->cost + dist[u] < dist[v])
			{
				
				dist[v] = dist[u] + pCrawl->cost;
				//path[v]=pCrawl->tailVex;
				path[v]=u;
				//距离更新了之后，要调整最小堆
				decreaseKey(minHeap, v, dist[v]);
				//printf("kankan\n");
				
			}
			pCrawl = pCrawl->nextLink;
		}
	}

	// 打印
	//printArr(dist, vNum);
	//printArr(path, vNum);
}

/*******************************************************************************************************/

/******************************************求最短路径主要算法*****************************************/
/**
*1、将没有加入到路中的点入堆
*2、第一个点设为起始点，因为是最小的
*3、每次选一个离原点最近的点出来更新其它点到原点的距离，直到遇到第一个必经节点，退出
*4、然后以这个必经节点为开始迭代更新
*/
int dijkstraClosed(OrGraph *G,int src,float dist[],int path[],int arc[],bool flag[], int *keyNum,int endv,bool isEnd){
	//最小优先队列，数组的方式,以后换feib堆。
	int vNum=G->vexNum;
	//printf("vNum=%d\n",vNum);
	//int dist[vNum];
	//我先只找到必经节点的最短距离，那么我不打endv加进来不就可以了吗，还费事，等找了这些之后再找最后一个必经到最后一个结点的值
	MinHeap* minHeap=createMinHeap(vNum);
	//初始化堆包含所有的顶点
	int i,j=1;
	minHeap->array[0]=newMinHeapNode(src,dist[src]);
	/*if(src==3){
		printf("这时进来的是%d\n", src);
	}
	for(int kk=0;kk<vNum;kk++)
	{
		box[kk]=-1;
		printf("kk=%d\n",kk );
	}*/
	/*printVal(box,vNum);
	printf("dist[%d]=%d\n",src,dist[src]);
	for(i=0;i<vNum;++i)
	{

		if(box[i]<0)//不加终点
		{
			printf("---------%d--%d\n",i,box[i]);
		dist[i]=MYINF;
		//path[i]=-1;
		minHeap->array[j]=newMinHeapNode(i,dist[i]);
		//printf("dist[%d]=%d\n",i,dist[i]);
		minHeap->pos[i]=j;
		++j;
		//path[i]=-1;
		}
		printf("++++++++++++++++box[%d]=%d\n",i,box[i] );
	}*/

	if(!isEnd)
	{	//printValBool(flag,vNum,"flag");
		//printf("-----------");
		//printVal(path,vNum,"path");
		//printf("-----endv=%d------\n",endv);
		//printVal(dist,vNum,"dist");
		//dist[14]=100;
		for(i=0;i<vNum;++i)
		{
			
			if(!flag[i]&&i!=endv)//不加终点
			{
				//printf("%d进堆",i);
				//printf("%d\n",i);
			dist[i]=MYINF;//dist[i]为MYINF可能
			//path[i]=-1;
			minHeap->array[j]=newMinHeapNode(i,dist[i]);
			//printf("dist[%d]=%d\n",i,dist[i]);
			minHeap->pos[i]=j;
			++j;
			path[i]=-1;
			}
		}
		//printf("\n");
	}
	else{
		for(i=0;i<vNum;++i)
		{
			if(!flag[i])//包含终点
			{

			dist[i]=MYINF;
			//path[i]=-1;
			minHeap->array[j]=newMinHeapNode(i,dist[i]);
			//printf("dist[%d]=%d\n",i,dist[i]);
			minHeap->pos[i]=j;
			++j;
			path[i]=-1;
			}
		}
	}
	G->clist[src].key=false;//源必为flase不然就出去了
	//G->clist[endv].key=false;
	//dist[src] = 0;
	//path[src]=src;//自己的前驱为自己
	//printf("进入堆中的点数=%d\n",j );
	minHeap->size = j;
	//exit(1);
	//minHeapify(minHeap,0);
	//decreaseKey(minHeap, src, dist[src]);
	int v;
	// 这个循环中，minHeap包含的是所有未在SPT中的顶点
	while (!isEmpty(minHeap)) {
		// 取得堆顶节点，即最小距离的顶点
		MinHeapNode* minHeapNode = extractMin(minHeap);
		int u = minHeapNode->v;
		free(minHeapNode);
		//flag[u]=true;//出堆则表明了这个点加入了最短路中？？？，不对只是最短路，但是不一定包含必经节点，所以要标记还是要完了之后单独标记
		//printf("u=%d,ucost=%d\n",u,minHeapNode->dist);
		if(G->clist[u].key)//加入堆中的是所有的flag为false的点。
		{
			//flag[u]=true;
				
			--*keyNum;
			//printf("出去了，返回u=%d\n",u);
			return u;
		}
		//printf("%s\n", );
		//flag[u]=true;
		// 只需要遍历和u相邻的顶点进行更新
		//printf("kankanhh\n");
		ArcNode* pCrawl = G->clist[u].firstLink;
		while (pCrawl != NULL) {

			v = pCrawl->headVex;
			//如果u结点连接的节点v为经过的节点则跳过这一个,如果v节点为endv节点的话，由于对endv节点是最后一次加入进去，且设为flag=false;
			//检醒所连接的点都是没有在路径上的，如果在的话则找下一个，加入堆中的节点都是还没有在路径上的
			if(flag[v])
			{
				pCrawl = pCrawl->nextLink;
				continue;
			}/**/
			
			//如果是endv的话但是不是最后一个结点，就下一个
			if(v==endv&&!isEnd)
			{
				pCrawl = pCrawl->nextLink;
				continue;
			}
			// 松弛操作，更新距离
			//printf("kankan3:v=%d\n",v);
			//如果不是最后一个必经节点不可以更新endv的距离
			
			if(isInMinHeap(minHeap, v)&& dist[u] != MYINF&& pCrawl->cost + dist[u] < dist[v])
			{
				//这里堆中点连接的点不是得经过的点则更新，他连接点的信息
				dist[v] = dist[u] + pCrawl->cost;
				//path[v]=pCrawl->tailVex;
				path[v]=u;
				//printf("path[%d]改变为%d,size=%d,dis[%d]=%d\n",v,u,minHeap->size,v,dist[v]);
				//printf("sssarc1\n");
				arc[v]=pCrawl->arcId;//arc[v]表示u->v的弧
				//if()
				//printf("sssarc2\n");
				//距离更新了之后，要调整最小堆
				decreaseKey(minHeap, v, dist[v]);//这里的v是节点编号，前面pos[v]=j;

			}
			
			pCrawl = pCrawl->nextLink;
		}
	}
	//printf("出去了-1\n");

	return -1;
	// 打印
	//printArr(dist, vNum);
	//printArr(path, vNum);
}
int dijkstraClosedNcost(OrGraph *G,int src,float dist[],int path[],int arc[],bool flag[], int *keyNum,int endv,bool isEnd){
	//最小优先队列，数组的方式,以后换feib堆。
	int vNum=G->vexNum;
	//printf("vNum=%d\n",vNum);
	//int dist[vNum];
	//我先只找到必经节点的最短距离，那么我不打endv加进来不就可以了吗，还费事，等找了这些之后再找最后一个必经到最后一个结点的值
	MinHeap* minHeap=createMinHeap(vNum);
	//初始化堆包含所有的顶点
	int i,j=1;
	minHeap->array[0]=newMinHeapNode(src,dist[src]);
	/*if(src==3){
		printf("这时进来的是%d\n", src);
	}
	for(int kk=0;kk<vNum;kk++)
	{
		box[kk]=-1;
		printf("kk=%d\n",kk );
	}*/
	/*printVal(box,vNum);
	printf("dist[%d]=%d\n",src,dist[src]);
	for(i=0;i<vNum;++i)
	{

		if(box[i]<0)//不加终点
		{
			printf("---------%d--%d\n",i,box[i]);
		dist[i]=MYINF;
		//path[i]=-1;
		minHeap->array[j]=newMinHeapNode(i,dist[i]);
		//printf("dist[%d]=%d\n",i,dist[i]);
		minHeap->pos[i]=j;
		++j;
		//path[i]=-1;
		}
		printf("++++++++++++++++box[%d]=%d\n",i,box[i] );
	}*/

	if(!isEnd)
	{	//printValBool(flag,vNum,"flag");
		//printf("-----------");
		//printVal(path,vNum,"path");
		//printf("-----endv=%d------\n",endv);
		//printVal(dist,vNum,"dist");
		//dist[14]=100;
		for(i=0;i<vNum;++i)
		{
			
			if(!flag[i]&&i!=endv)//不加终点
			{
				//printf("%d进堆",i);
				//printf("%d\n",i);
			dist[i]=MYINF;//dist[i]为MYINF可能
			//path[i]=-1;
			minHeap->array[j]=newMinHeapNode(i,dist[i]);
			//printf("dist[%d]=%d\n",i,dist[i]);
			minHeap->pos[i]=j;
			++j;
			path[i]=-1;
			}
		}
		//printf("\n");
	}
	else{
		for(i=0;i<vNum;++i)
		{
			if(!flag[i])//包含终点
			{

			dist[i]=MYINF;
			//path[i]=-1;
			minHeap->array[j]=newMinHeapNode(i,dist[i]);
			//printf("dist[%d]=%d\n",i,dist[i]);
			minHeap->pos[i]=j;
			++j;
			path[i]=-1;
			}
		}
	}
	G->clist[src].key=false;//源必为flase不然就出去了
	//G->clist[endv].key=false;
	//dist[src] = 0;
	//path[src]=src;//自己的前驱为自己
	//printf("进入堆中的点数=%d\n",j );
	minHeap->size = j;
	//exit(1);
	//minHeapify(minHeap,0);
	//decreaseKey(minHeap, src, dist[src]);
	int v;
	// 这个循环中，minHeap包含的是所有未在SPT中的顶点
	while (!isEmpty(minHeap)) {
		// 取得堆顶节点，即最小距离的顶点
		MinHeapNode* minHeapNode = extractMin(minHeap);
		int u = minHeapNode->v;
		free(minHeapNode);
		//flag[u]=true;//出堆则表明了这个点加入了最短路中？？？，不对只是最短路，但是不一定包含必经节点，所以要标记还是要完了之后单独标记
		//printf("u=%d,ucost=%d\n",u,minHeapNode->dist);
		if(G->clist[u].key)//加入堆中的是所有的flag为false的点。
		{
			//flag[u]=true;
				
			--*keyNum;
			//printf("出去了，返回u=%d\n",u);
			return u;
		}
		//printf("%s\n", );
		//flag[u]=true;
		// 只需要遍历和u相邻的顶点进行更新
		//printf("kankanhh\n");
		ArcNode* pCrawl = G->clist[u].firstLink;
		while (pCrawl != NULL) {

			v = pCrawl->headVex;
			//如果u结点连接的节点v为经过的节点则跳过这一个,如果v节点为endv节点的话，由于对endv节点是最后一次加入进去，且设为flag=false;
			//检醒所连接的点都是没有在路径上的，如果在的话则找下一个，加入堆中的节点都是还没有在路径上的
			if(flag[v])
			{
				pCrawl = pCrawl->nextLink;
				continue;
			}/**/
			
			//如果是endv的话但是不是最后一个结点，就下一个
			if(v==endv&&!isEnd)
			{
				pCrawl = pCrawl->nextLink;
				continue;
			}
			// 松弛操作，更新距离
			//printf("kankan3:v=%d\n",v);
			//如果不是最后一个必经节点不可以更新endv的距离
			
			if(isInMinHeap(minHeap, v)&& dist[u] != MYINF&& pCrawl->Ncost + dist[u] < dist[v])
			{
				//这里堆中点连接的点不是得经过的点则更新，他连接点的信息
				dist[v] = dist[u] + pCrawl->Ncost;
				//path[v]=pCrawl->tailVex;
				path[v]=u;
				//printf("path[%d]改变为%d,size=%d,dis[%d]=%d\n",v,u,minHeap->size,v,dist[v]);
				//printf("sssarc1\n");
				arc[v]=pCrawl->arcId;//arc[v]表示u->v的弧
				//if()
				//printf("sssarc2\n");
				//距离更新了之后，要调整最小堆
				decreaseKey(minHeap, v, dist[v]);//这里的v是节点编号，前面pos[v]=j;
				//这里出线段错误是因为没有把点比如说终点加入堆中，但是这里却要更新终点的值
				//printf("%d的前驱为%d,dist[%d]=%d\n",v,u,v,dist[v]);
				//minHeapify(minHeap,0);
				//MinHeapNode* minHeapNode = extractMin(minHeap);
				//int u = minHeapNode->v;
				//printf("下一次最小的为=%d,值为%d\n",u,minHeapNode->dist);
				//exit(1);
				//printf("kankan1:---------------k=%d\n",k);
			}
			
			pCrawl = pCrawl->nextLink;
		}
	}
	//printf("出去了-1\n");

	return -1;
	// 打印
	//printArr(dist, vNum);
	//printArr(path, vNum);
}
bool minPath(OrGraph *G,int arr_se[],float dist[],int arc[],bool flag[],int path[]){
	//a->b
	int m,k,keyNum,endv,begn;
	bool isEnd=false;
	begn=arr_se[0];
	endv=arr_se[1];
	keyNum=arr_se[2];

	for(int o=0;o<G->vexNum;o++)
	{
		flag[o]=false;
		path[o]=-1;
		arc[o]=-1;
		dist[o]=MYINF;
	}
		/*------------------------------------求到初始点的第一个最短的必经节点---------------------------------*/
	flag[arr_se[0]]=true;//初始点标记为经过
	path[arr_se[0]]=arr_se[0];//前驱节点为自己
	dist[arr_se[0]]=0;//与前驱节点距离为零
	//printf("-----minPath------\n");
	//printVal(path,G->vexNum,"path");
	//printVal(dist,G->vexNum,"dist");
	//printf("-----minPath-end-----\n");
	//for(int i=)
	//n=dijkstraClosed(G,n,dist,path,flag,&keyNum,endv);
	//int i=0;
	while(begn!=-1&&keyNum>0)
	{
		//printf("************循环第%d次哈哈v=%d,keyNum=%d***************\n",++i,begn,keyNum);
		m=begn;
		//dijkstraClosed(OrGraph *G,int src,int *dist,int *path,int *arc, int *keyNum,int endv,bool isEnd,int box[20])
		begn=dijkstraClosed(G,begn,dist,path,arc,flag,&keyNum,endv,isEnd);
		k=begn;
		//exit(1);
		/*printVal(dist,start_end[2],"dist");
		printVal(arc,start_end[2],"arc");
		printValBool(flag,start_end[2],"flag");
		printVal(path,start_end[2],"path");
		*/
		//printf("************第%d次循环返回哈哈v=%d,keyNum=%d***************\n",i,begn,keyNum);
		/*更新flag标记，把新找到的路加入到路径中*/
		//m为前一个必经点，k为找到的后一个必经点，把必经点到必经点的路上的所有点标记为经过。包括后一个必经点
		//printf("前驱%d,后继%d\n",m,n);
		//int kk=0;
		while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
		{
			//printf("k1=%d\n", k);
			//printf("k1=%d\n", k,"dist");
			//flag[k]=true;//包括n点更新为经过，直到n的前一个必经节点m为止，而m的经过之前设置过了
			//box[k]=1;
			//printf("%d前驱为%d\n",k,path[k]);
			flag[k]=true;
			k=path[k];
			//kk++;
			//printf("k2=%d\n", k);
			//if(kk>6){break;}	
		}

		//if(keyNum<0)break;
		//printf("while11111\n");	
	}
	//G->clist[start_end[1]].key=true;//设置返回条件
	isEnd=true;
	if(begn>=0)
	{
		//printf("-----------m=%d\n",m );
		//printf("-1keyNum=%d\n",keyNum );
		dijkstraClosed(G,begn,dist,path,arc,flag,&keyNum,endv,isEnd);
	}
	/*if(keyNum==0){
		//printf("-----------n=%d\n",n );
		//printf("keyNum=%d\n",keyNum );
		dijkstraClosed(G,begn,dist,path,arc,flag,&keyNum,endv,isEnd);
	}*/

	if(path[arr_se[1]]!=-1)
	{
		return true;
	}
	return false;	
}
bool minPathNcost(OrGraph *G,int arr_se[],float dist[],int arc[],bool flag[],int path[]){
	//a->b
	int m,k,keyNum,endv,begn;
	bool isEnd=false;
	begn=arr_se[0];
	endv=arr_se[1];
	keyNum=arr_se[2];

	for(int o=0;o<G->vexNum;o++)
	{
		flag[o]=false;
		path[o]=-1;
		arc[o]=-1;
		dist[o]=MYINF;
	}
		/*------------------------------------求到初始点的第一个最短的必经节点---------------------------------*/
	flag[arr_se[0]]=true;//初始点标记为经过
	path[arr_se[0]]=arr_se[0];//前驱节点为自己
	dist[arr_se[0]]=0;//与前驱节点距离为零
	//printf("-----minPath------\n");
	//printVal(path,G->vexNum,"path");
	//printVal(dist,G->vexNum,"dist");
	//printf("-----minPath-end-----\n");
	//for(int i=)
	//n=dijkstraClosed(G,n,dist,path,flag,&keyNum,endv);
	//int i=0;
	while(begn!=-1&&keyNum>0)
	{
		//printf("************循环第%d次哈哈v=%d,keyNum=%d***************\n",++i,begn,keyNum);
		m=begn;
		//dijkstraClosed(OrGraph *G,int src,int *dist,int *path,int *arc, int *keyNum,int endv,bool isEnd,int box[20])
		begn=dijkstraClosedNcost(G,begn,dist,path,arc,flag,&keyNum,endv,isEnd);
		k=begn;
		//exit(1);
		/*printVal(dist,start_end[2],"dist");
		printVal(arc,start_end[2],"arc");
		printValBool(flag,start_end[2],"flag");
		printVal(path,start_end[2],"path");
		*/
		//printf("************第%d次循环返回哈哈v=%d,keyNum=%d***************\n",i,begn,keyNum);
		/*更新flag标记，把新找到的路加入到路径中*/
		//m为前一个必经点，k为找到的后一个必经点，把必经点到必经点的路上的所有点标记为经过。包括后一个必经点
		//printf("前驱%d,后继%d\n",m,n);
		//int kk=0;
		while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
		{
			//printf("k1=%d\n", k);
			//printf("k1=%d\n", k,"dist");
			//flag[k]=true;//包括n点更新为经过，直到n的前一个必经节点m为止，而m的经过之前设置过了
			//box[k]=1;
			//printf("%d前驱为%d\n",k,path[k]);
			flag[k]=true;
			k=path[k];
			//kk++;
			//printf("k2=%d\n", k);
			//if(kk>6){break;}	
		}

		//if(keyNum<0)break;
		//printf("while11111\n");	
	}
	//G->clist[start_end[1]].key=true;//设置返回条件
	isEnd=true;
	if(begn>=0)
	{
		//printf("-----------m=%d\n",m );
		//printf("-1keyNum=%d\n",keyNum );
		dijkstraClosedNcost(G,begn,dist,path,arc,flag,&keyNum,endv,isEnd);
	}
	/*if(keyNum==0){
		//printf("-----------n=%d\n",n );
		//printf("keyNum=%d\n",keyNum );
		dijkstraClosed(G,begn,dist,path,arc,flag,&keyNum,endv,isEnd);
	}*/

	if(path[arr_se[1]]!=-1)
	{
		return true;
	}
	return false;	
}
bool minPathMidst(OrGraph *G,OrGraph *RG, int start_end[],int mid,float dist[],int arc[],bool flag[],int path[],int unvoid[]){
	//a->b
	int m,n,k,keyNum;
	//ArcNode* w;
	bool isEnd=false;
	keyNum=start_end[2];
	n=mid;
	//printf("1__%d\n", mid);

	for(int o=0; o<start_end[2]; o++)
	{
		G->clist[unvoid[o]].key=true;
		RG->clist[unvoid[o]].key=true;
	}
	G->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
	G->clist[start_end[1]].key=true;
	RG->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
	RG->clist[start_end[1]].key=true;
	//初始化标记
	for(int o=0;o<G->vexNum;o++)
	{
		flag[o]=false;
		path[o]=-1;
		arc[o]=-1;
		dist[o]=MYINF;
	}
	flag[mid]=true;//初始点标记为经过
	//printf("%d\n",mid);
	path[mid]=mid;//前驱节点为自己
	dist[mid]=0;//与前驱节点距离为零


	//printf("\n----进入中间1-minPathMidist------\n");
	//int i=0;
	while(n!=-1&&n!=start_end[0])//先逆向找头结点
	{
		//printf("*******11111111*****循环第%d次哈哈v=%d,keyNum=%d***************\n",++i,n,keyNum);
		m=n;
		n=dijkstraClosed(RG,n,dist,path,arc,flag,&keyNum,start_end[1],isEnd);//排除开始节点进入
		k=n;
		//printf("path[%d]=---=%d  \n", n,path[n]);
		while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
		{

			flag[k]=true;
			k=path[k];

		}
		//printf("\n\n----111---n=%d----dist[%d]=%d---keyNum=%d，进入最后关头------------\n\n",n,n,dist[n],keyNum);
	}

	//printf("\n\n----222---n=%d----dist[%d]=%d---keyNum=%d，进入最后关头------------\n\n",n,n,dist[n],keyNum);
	if(path[start_end[0]]!=-1)
	{//先通过逆邻接表找到起点，然后再去找终点
		
		//终点前一个节点到终点的距离，当begn为-1表明前一个begn并没有找到下一个必经节点
		//可能是必经节点都走完了，也可能是没有到其它必经的路
		//这时keyNum不为零的话则没有找完必经节点
		//printf("\n\n==============================\n\n");
		n=mid;
		while(n!=-1&&keyNum>0)
		{
			//printf("*****=222222222==============*******循环第%d次哈哈,n=%d,keyNum=%d*******============********\n",++i,n,keyNum);
			m=n;
			n=dijkstraClosed(G,n,dist,path,arc,flag,&keyNum,start_end[1],isEnd);//中点到开始点，由于这是逆邻接表，所以要最后到开始点
			k=n;

			while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
			{
				flag[k]=true;
				k=path[k];
			}
		}
		//printf("\n\n---33----n=%d-------keyNum=%d，进入最后关头------------\n\n",n,keyNum);
		if(n>=0)
		{
			isEnd=true;
			n=dijkstraClosed(G,n,dist,path,arc,flag,&keyNum,mid,isEnd);
			//printf("\n\n---44----n=%d-------keyNum=%d，进入最后关头------------\n\n",n,keyNum);
		}
	}

	
	if(path[start_end[1]]!=-1)//!=-1
	{
		
		//如果终点找到了的话，则进行相应表的数据的整理，由于逆序与下序所以表记录的不一样，下面转化为一样的
		n=start_end[0];

		m=arc[n];
		while(n!=path[n]&&n!=path[path[n]])
		{
			k=arc[path[n]];
			arc[path[n]]=m;
			m=k;
			n=path[n];

		}
		arc[start_end[0]]=m;
		n=start_end[0];
		m=path[n];
		while(m!=path[m]&&m!=path[path[m]])
		{
			//h=m;
			k=path[m];
			path[m]=n;
			n=m;
			m=k;
			//printf(" path[%d]=%d  |===|",m,path[m]);
		}
		//printf(" path[%d]=%d  |=2=2=======|\n",n,m);
		path[m]=n;
		path[start_end[0]]=start_end[0];
		
		return true;
	}
	else//这里是先找尾后找头，前面是先找头后找尾，
	{
		//否则再找，先通过中点顺序向下找，再通过中点逆序向上找
		//----------重新初始化------------
		//printf("\n--++++++++++++++++++++++进入中间2---minPathMidist------\n");
		for(int o=0; o<start_end[2]; o++)
		{
			G->clist[unvoid[o]].key=true;
			RG->clist[unvoid[o]].key=true;
		}
		G->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
		G->clist[start_end[1]].key=true;
		RG->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
		RG->clist[start_end[1]].key=true;
		//初始化标记
		for(int o=0;o<G->vexNum;o++)
		{
			flag[o]=false;
			path[o]=-1;
			arc[o]=-1;
			dist[o]=MYINF;
		}
		flag[mid]=true;//初始点标记为经过
		path[mid]=mid;//前驱节点为自己
		dist[mid]=0;//与前驱节点距离为零

		isEnd=false;

		keyNum=start_end[2];
		n=mid;
		
		while(n!=-1&&n!=start_end[1])//从中间点到终点如遇到就返回
		{
			//printf("****33333333333********循环第%d次哈哈v=%d,keyNum=%d***************\n",++i,n,keyNum);
			m=n;
			//dijkstraClosed(OrGraph *G,int src,int *dist,int *path,int *arc, int *keyNum,int endv,bool isEnd,int box[20])
			n=dijkstraClosed(G,n,dist,path,arc,flag,&keyNum,start_end[0],isEnd);//排除开始节点进入
			k=n;
			//printf("dist[%d]=%d,keyNum=%d___________\n",n,dist[n],keyNum );
			//exit(1);
			//printf("************第%d次循环返回哈哈v=%d,keyNum=%d***************\n",i,begn,keyNum);
			/*更新flag标记，把新找到的路加入到路径中*/
			//m为前一个必经点，k为找到的后一个必经点，把必经点到必经点的路上的所有点标记为经过。包括后一个必经点
			//printf("前驱%d,后继%d\n",m,n);
			while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
			{
				//把经过的点标记为真，以示用过，由于n可能为-1所以用m;
				flag[k]=true;
				k=path[k];
			}
			//if(keyNum<=0)break;//当必经节点完了则退出，此时begn为在终点的前一个节点,这句其实没什么用，只是防止程序出错时，死循环。但当它是<=0时就有作用了，防止

		}
		//如果begn==-1则没搜到
		//如果begn为end则从中间点再搜到头，或从头搜到中间节点，看是邻接表还是逆邻接表
		//printf("--1---------n=%d\n",n );
		if(path[start_end[1]]!=-1)//正序时出来时终点，就是前面找到终点了的话，就开始找头
		{
			
			//printf("-1keyNum=%d\n",keyNum );
			
			//终点前一个节点到终点的距离，当begn为-1表明前一个begn并没有找到下一个必经节点
			//可能是必经节点都走完了，也可能是没有到其它必经的路
			//这时keyNum不为零的话则没有找完必经节点
			//printf("\n\n========进入找头结点======================\n\n");
			n=mid;

			while(n!=-1&&keyNum>0)
			{
				//printf("*****==4444444444=============*******循环第%d次哈哈,n=%d,keyNum=%d*******============********\n",++i,n,keyNum);


				m=n;
				n=dijkstraClosed(RG,n,dist,path,arc,flag,&keyNum,start_end[0],isEnd);//中点到开始点，由于这是逆邻接表，所以要最后到开始点
				//printf("dist[%d]=%d,keyNum=%d\n",n,dist[n],keyNum );
				k=n;
				while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
				{
					//把经过的点标记为真，以示用过，由于n可能为-1所以用m;
					flag[k]=true;
					k=path[k];

				}
			}
			
			if(n>=0)
			{
				isEnd=true;
				//m=n;
				dijkstraClosed(RG,n,dist,path,arc,flag,&keyNum,mid,isEnd);
				
				//printf("1111111---------m=%d,n=%d,keyNum=%d,dist[%d]=%d\n",m,n,keyNum,n,dist[n]);
				
			}
		}

		if(path[start_end[0]]!=-1)//如果头结点也找到了那就对了
		{
			//printf("\ntou____________________======================\n" );
			//把弧逆向的一边正过来，因为arc[v]是记录u->v的弧，所以在逆向找的过程中起点记录的是记录的到他的点的逆向弧，就是正向的起始弧，通过结点前驱的方式找到
			n=start_end[0];
			m=arc[n];
			while(n!=path[n]&&n!=path[path[n]])
			{
				//h=m;
				//printf("--------------%d------%d--\n",path[n],m);
				k=arc[path[n]];//记录前驱的弧
				arc[path[n]]=m;//前驱的弧，变成正向的位置，依次挪一位
				m=k;
				n=path[n];
				//n=path[n];
				//tmpPath[path[n]]=
			}
			arc[start_end[0]]=m;


			n=start_end[0];
			//tmpPath[n]=n;
			m=path[n];
			//h=n;
			//printf("h=%d\n",h );
			while(m!=path[m]&&m!=path[path[m]])
			{
				//h=m;
				k=path[m];
				path[m]=n;
				n=m;
				m=k;
				//n=path[n];
				//tmpPath[path[n]]=
			}
			path[m]=n;
			path[start_end[0]]=start_end[0];
		/*	for(int i=0;i<G->vexNum;i++)
				{
					printf(" path[%d]=%d  ",i,path[i]);
					printf(" dist[%d]=%d  ",i,dist[i]);
					printf(" arc[%d]=%d  ",i,arc[i]);
				}*/
			return true;
		}
	}
	return false;	
}
bool minPathMidstNcost(OrGraph *G,OrGraph *RG, int start_end[],int mid,float dist[],int arc[],bool flag[],int path[],int unvoid[]){
	//a->b
	int m,n,k,keyNum;
	//ArcNode* w;
	bool isEnd=false;
	keyNum=start_end[2];
	n=mid;
	//printf("1__%d\n", mid);

	for(int o=0; o<start_end[2]; o++)
	{
		G->clist[unvoid[o]].key=true;
		RG->clist[unvoid[o]].key=true;
	}
	G->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
	G->clist[start_end[1]].key=true;
	RG->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
	RG->clist[start_end[1]].key=true;
	//初始化标记
	for(int o=0;o<G->vexNum;o++)
	{
		flag[o]=false;
		path[o]=-1;
		arc[o]=-1;
		dist[o]=MYINF;
	}
	flag[mid]=true;//初始点标记为经过
	//printf("%d\n",mid);
	path[mid]=mid;//前驱节点为自己
	dist[mid]=0;//与前驱节点距离为零


	//printf("\n----进入中间1-minPathMidist------\n");
	//int i=0;
	while(n!=-1&&n!=start_end[0])//先逆向找头结点
	{
		//printf("*******11111111*****循环第%d次哈哈v=%d,keyNum=%d***************\n",++i,n,keyNum);
		m=n;
		n=dijkstraClosedNcost(RG,n,dist,path,arc,flag,&keyNum,start_end[1],isEnd);//排除开始节点进入
		k=n;
		//printf("path[%d]=---=%d  \n", n,path[n]);
		while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
		{

			flag[k]=true;
			k=path[k];

		}
		//printf("\n\n----111---n=%d----dist[%d]=%d---keyNum=%d，进入最后关头------------\n\n",n,n,dist[n],keyNum);
	}

	//printf("\n\n----222---n=%d----dist[%d]=%d---keyNum=%d，进入最后关头------------\n\n",n,n,dist[n],keyNum);
	if(path[start_end[0]]!=-1)
	{//先通过逆邻接表找到起点，然后再去找终点
		
		//终点前一个节点到终点的距离，当begn为-1表明前一个begn并没有找到下一个必经节点
		//可能是必经节点都走完了，也可能是没有到其它必经的路
		//这时keyNum不为零的话则没有找完必经节点
		//printf("\n\n==============================\n\n");
		n=mid;
		while(n!=-1&&keyNum>0)
		{
			//printf("*****=222222222==============*******循环第%d次哈哈,n=%d,keyNum=%d*******============********\n",++i,n,keyNum);
			m=n;
			n=dijkstraClosedNcost(G,n,dist,path,arc,flag,&keyNum,start_end[1],isEnd);//中点到开始点，由于这是逆邻接表，所以要最后到开始点
			k=n;

			while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
			{
				flag[k]=true;
				k=path[k];
			}
		}
		//printf("\n\n---33----n=%d-------keyNum=%d，进入最后关头------------\n\n",n,keyNum);
		if(n>=0)
		{
			isEnd=true;
			n=dijkstraClosedNcost(G,n,dist,path,arc,flag,&keyNum,mid,isEnd);
			//printf("\n\n---44----n=%d-------keyNum=%d，进入最后关头------------\n\n",n,keyNum);
		}
	}

	
	if(path[start_end[1]]!=-1)//!=-1
	{
		
		//如果终点找到了的话，则进行相应表的数据的整理，由于逆序与下序所以表记录的不一样，下面转化为一样的
		n=start_end[0];

		m=arc[n];
		while(n!=path[n]&&n!=path[path[n]])
		{
			k=arc[path[n]];
			arc[path[n]]=m;
			m=k;
			n=path[n];

		}
		arc[start_end[0]]=m;
		n=start_end[0];
		m=path[n];
		while(m!=path[m]&&m!=path[path[m]])
		{
			//h=m;
			k=path[m];
			path[m]=n;
			n=m;
			m=k;
			//printf(" path[%d]=%d  |===|",m,path[m]);
		}
		//printf(" path[%d]=%d  |=2=2=======|\n",n,m);
		path[m]=n;
		path[start_end[0]]=start_end[0];
		
		return true;
	}
	else//这里是先找尾后找头，前面是先找头后找尾，
	{
		//否则再找，先通过中点顺序向下找，再通过中点逆序向上找
		//----------重新初始化------------
		//printf("\n--++++++++++++++++++++++进入中间2---minPathMidist------\n");
		for(int o=0; o<start_end[2]; o++)
		{
			G->clist[unvoid[o]].key=true;
			RG->clist[unvoid[o]].key=true;
		}
		G->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
		G->clist[start_end[1]].key=true;
		RG->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
		RG->clist[start_end[1]].key=true;
		//初始化标记
		for(int o=0;o<G->vexNum;o++)
		{
			flag[o]=false;
			path[o]=-1;
			arc[o]=-1;
			dist[o]=MYINF;
		}
		flag[mid]=true;//初始点标记为经过
		path[mid]=mid;//前驱节点为自己
		dist[mid]=0;//与前驱节点距离为零

		isEnd=false;

		keyNum=start_end[2];
		n=mid;
		
		while(n!=-1&&n!=start_end[1])//从中间点到终点如遇到就返回
		{
			//printf("****33333333333********循环第%d次哈哈v=%d,keyNum=%d***************\n",++i,n,keyNum);
			m=n;
			//dijkstraClosed(OrGraph *G,int src,int *dist,int *path,int *arc, int *keyNum,int endv,bool isEnd,int box[20])
			n=dijkstraClosedNcost(G,n,dist,path,arc,flag,&keyNum,start_end[0],isEnd);//排除开始节点进入
			k=n;
			//printf("dist[%d]=%d,keyNum=%d___________\n",n,dist[n],keyNum );
			//exit(1);
			//printf("************第%d次循环返回哈哈v=%d,keyNum=%d***************\n",i,begn,keyNum);
			/*更新flag标记，把新找到的路加入到路径中*/
			//m为前一个必经点，k为找到的后一个必经点，把必经点到必经点的路上的所有点标记为经过。包括后一个必经点
			//printf("前驱%d,后继%d\n",m,n);
			while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
			{
				//把经过的点标记为真，以示用过，由于n可能为-1所以用m;
				flag[k]=true;
				k=path[k];
			}
			//if(keyNum<=0)break;//当必经节点完了则退出，此时begn为在终点的前一个节点,这句其实没什么用，只是防止程序出错时，死循环。但当它是<=0时就有作用了，防止

		}
		//如果begn==-1则没搜到
		//如果begn为end则从中间点再搜到头，或从头搜到中间节点，看是邻接表还是逆邻接表
		//printf("--1---------n=%d\n",n );
		if(path[start_end[1]]!=-1)//正序时出来时终点，就是前面找到终点了的话，就开始找头
		{
			
			//printf("-1keyNum=%d\n",keyNum );
			
			//终点前一个节点到终点的距离，当begn为-1表明前一个begn并没有找到下一个必经节点
			//可能是必经节点都走完了，也可能是没有到其它必经的路
			//这时keyNum不为零的话则没有找完必经节点
			//printf("\n\n========进入找头结点======================\n\n");
			n=mid;

			while(n!=-1&&keyNum>0)
			{
				//printf("*****==4444444444=============*******循环第%d次哈哈,n=%d,keyNum=%d*******============********\n",++i,n,keyNum);


				m=n;
				n=dijkstraClosedNcost(RG,n,dist,path,arc,flag,&keyNum,start_end[0],isEnd);//中点到开始点，由于这是逆邻接表，所以要最后到开始点
				//printf("dist[%d]=%d,keyNum=%d\n",n,dist[n],keyNum );
				k=n;
				while(m!=k&&k>=0)//这里要>=0由于0节点的点前驱也要赋值
				{
					//把经过的点标记为真，以示用过，由于n可能为-1所以用m;
					flag[k]=true;
					k=path[k];

				}
			}
			
			if(n>=0)
			{
				isEnd=true;
				//m=n;
				dijkstraClosedNcost(RG,n,dist,path,arc,flag,&keyNum,mid,isEnd);
				
				//printf("1111111---------m=%d,n=%d,keyNum=%d,dist[%d]=%d\n",m,n,keyNum,n,dist[n]);
				
			}
		}

		if(path[start_end[0]]!=-1)//如果头结点也找到了那就对了
		{
			//printf("\ntou____________________======================\n" );
			//把弧逆向的一边正过来，因为arc[v]是记录u->v的弧，所以在逆向找的过程中起点记录的是记录的到他的点的逆向弧，就是正向的起始弧，通过结点前驱的方式找到
			n=start_end[0];
			m=arc[n];
			while(n!=path[n]&&n!=path[path[n]])
			{
				//h=m;
				//printf("--------------%d------%d--\n",path[n],m);
				k=arc[path[n]];//记录前驱的弧
				arc[path[n]]=m;//前驱的弧，变成正向的位置，依次挪一位
				m=k;
				n=path[n];
				//n=path[n];
				//tmpPath[path[n]]=
			}
			arc[start_end[0]]=m;


			n=start_end[0];
			//tmpPath[n]=n;
			m=path[n];
			//h=n;
			//printf("h=%d\n",h );
			while(m!=path[m]&&m!=path[path[m]])
			{
				//h=m;
				k=path[m];
				path[m]=n;
				n=m;
				m=k;
				//n=path[n];
				//tmpPath[path[n]]=
			}
			path[m]=n;
			path[start_end[0]]=start_end[0];
		/*	for(int i=0;i<G->vexNum;i++)
				{
					printf(" path[%d]=%d  ",i,path[i]);
					printf(" dist[%d]=%d  ",i,dist[i]);
					printf(" arc[%d]=%d  ",i,arc[i]);
				}*/
			return true;
		}
	}
	return false;	
}

/***********************************************************************************************************/

/**************************************************逆邻接表工具函数*****************************************/
//转换起始点与初始点，在用逆邻接表时要把原来的终点转换为起点
void changeStart_end(int se[]){
	int tmp;
	tmp=se[1];
	se[1]=se[0];
	se[0]=tmp;
}

/***********************************************************************************************************/
//计算权值
//int allCost()
//打印
void printArr(int arr[],int n,char *p)
{
	printf("%s:,",p);
	for(int i=0;i<n;i++)
	{
		printf("%d,",arr[i]);
	}
	printf("\n");
}
//找到弧权值
int findArcCost(OrGraph *G,int pnode,int arcId)
{
	
	//int arcn=-1;
	if(pnode<0){return 0;}
	int cost=MYINF;
	ArcNode *p= G->clist[pnode].firstLink;
	while(p!=NULL)
	{
		if(p->arcId==arcId)
		{
			//printf("%d,%d\n",nnode,cost );
			//arcn=p->arcId;
			cost=p->cost;
			return cost;//有弧id是确定的
		}
		p=p->nextLink;
	}
	return cost;
}
/**************************************************执行入口函数*********************************************/
//void initData(OrGraph *G,char *topo[5000],int edge_num, bool isRev,int unvoid[],int start_end[])
void search_route(char *topo[5000], int edge_num, char *demand){
	
	/***********************************准备工作***********************************************/
	/*-----------------------------申明邻接表,标记数组---------------------- ----*/
	/*OrGraph *RG,*G;
	OrGraph ROG,OG;
	RG=&ROG;
	G=&OG;*/
	OrGraph *RG=(OrGraph *)calloc(1,sizeof(OrGraph));	
	OrGraph *G=(OrGraph *)calloc(1,sizeof(OrGraph));
	OrGraph *RG_C=(OrGraph *)calloc(1,sizeof(OrGraph));	
	OrGraph *G_C=(OrGraph *)calloc(1,sizeof(OrGraph));
	//NodeDegree *ND=NULL;	
	//选择最大节点数，初始化邻接表
	//memset(RG,0,sizeof(ROG));
	//memset(G,0,sizeof(OG));
	/*for(int k=0;k<MAX_VERTEX;k++)
	{
		G->clist[k].firstLink=NULL;
		G->clist[k].key=false;
		G->clist[k].outDegree=0;
		G->clist[k].inDegree=0;
	}*/

	/*-----------------解析demand命令，找出始末点，必经点个数，以及存放必经点------*/
	//start_end[0]为起点,start_end[1]为终点,start_end[2]为必经点个数
	int start_end[3];//正数组
	int Rstart_end[3];//逆数组
	int unvoid[50];//unvoid为必经点数组
	explain_demand(start_end,unvoid,demand);
	for(int i=0;i<3;i++){Rstart_end[i]=start_end[i];}//赋值
	changeStart_end(Rstart_end);//调换头尾节点，用于逆邻接表
	
	
	/*-----------------------------建立逆邻接表，或逆邻接表--------------------*/
	/*
	RG->vexNum=0;
	RG->arcNum=0;
	G->vexNum=0;
	G->arcNum=0;
	*/
	bool isRev=false;
	createOG(G, topo,edge_num,isRev);
	createOG(G_C, topo,edge_num,isRev);
	isRev=true;
	createOG(RG, topo,edge_num,isRev);
	createOG(RG_C, topo,edge_num,isRev);

	//RG->clist[Rstart_end[1]].firstLink=NULL;//终点出度为零，其实这个可有可无
	//G->clist[start_end[1]].firstLink=NULL;
	/*-------------------------------------------初始化必经点------------------------*/
	for(int i=0; i<Rstart_end[2]; i++)
	{
		RG->clist[unvoid[i]].key=true;
		G->clist[unvoid[i]].key=true;

		RG_C->clist[unvoid[i]].key=true;
		G_C->clist[unvoid[i]].key=true;
	}
	RG->clist[Rstart_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
	RG->clist[Rstart_end[1]].key=true;//终点为必经节点，在路径检测时间会用到
	G->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
	G->clist[start_end[1]].key=true;//终点为必经节点，在路径检测时间会用到

	RG_C->clist[Rstart_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
	RG_C->clist[Rstart_end[1]].key=true;//终点为必经节点，在路径检测时间会用到
	G_C->clist[start_end[0]].key=true;//第一个节点也是必经点，因为在上面算法中需要找必经节点的前一个必经节点。
	G_C->clist[start_end[1]].key=true;//终点为必经节点，在路径检测时间会用到




	/*------------------------------------入度或出度为1的必经节点其前驱和后继的减枝-------—--------------------------*/
	bool *mark1=(bool *)calloc(G->vexNum+1,sizeof(bool));//假定这个点是连续的才行啊，不行就改成MAX_VEX
	bool *mark2=(bool *)calloc(G->vexNum+1,sizeof(bool));//假定这个点是连续的才行啊，不行就改成MAX_VEX
	//outputAllDegree_Arr(G);
	//outputCriDegree_Arr(G,unvoid,start_end);
	removeBENode(G,RG_C,start_end);
	removeBENode(RG,G_C,Rstart_end);
	removeZero(G, RG_C,start_end,mark1,mark2);//这个加上还有错，晕
	removeZero(RG,G_C, Rstart_end,mark1,mark2);
	//printf("999999999\n");
	cut(G,RG_C,unvoid,start_end,mark1,mark2);//剪枝,应该至少没有影响才对，还有问题
	cut(RG,G_C,unvoid,Rstart_end,mark1,mark2);
	
	updateNCostA(G);
	updateNCostA(RG);
	//testOutNcost(G);
	//printf("-----------------------------------------\n");
	//outputAllDegree_Arr(G);
	//outputCriDegree_Arr(G,unvoid,start_end);

/*-----------------------------------------------初始化标记数组----------------------------------------*/
	
	int path[RG->vexNum];//前驱数组
	bool flag[RG->vexNum];//标记数组
	float dist[RG->vexNum];//距离数组
	int arc[RG->vexNum];//弧标记

	//float distNcost[RG->vexNum];

	//记录最小的
	float cost=MYINF,cost1;
	int path_min[RG->vexNum];
	int arc_min[RG->vexNum];
	memset(path_min,-1,sizeof(path_min));
	memset(arc_min,-1,sizeof(arc_min));
	


/*------------------------------------------------开始计算----------------------------------------------*/
	int minCost=MYINF;

	int k=0;

//顶点小于300用ABCD算法
	if(G->vexNum<=300)	
	{	
//0		
		if(minPath(RG,Rstart_end,dist,arc,flag,path))
		{
			k=1;
			cost1=calCost(RG,Rstart_end[1],path,arc);
			//printf("cost=%d, cost1=%d\n",cost,cost1);
			if(cost1<cost)
			{
				cost=cost1;
				memcpy(path_min,path,sizeof(path));
				memcpy(arc_min,arc,sizeof(arc));
				isRev=true;
			}
		}
		
		if(minPath(G,start_end,dist,arc,flag,path))
		{
			k=1;
			cost1=calCost(G,start_end[1],path,arc);
			//printf("cost=%d, cost1=%d\n",cost,cost1);
			if(cost1<cost)
			{
				cost=cost1;
				memcpy(path_min,path,sizeof(path));
				memcpy(arc_min,arc,sizeof(arc));
				isRev=false;
			}
		}
		
		for(int i=0;i<start_end[2];i++)
		{
			//printf("%d , %d\n",i,ND[i].v );
			//printf("%d___%d\n", i,start_end[i]);
			if(minPathMidst(G,RG,start_end,unvoid[i],dist,arc,flag,path,unvoid))
			{
				k=1;
				cost1=calCost(G,start_end[1],path,arc);
				//printf("cost=%d, cost1=%d\n",cost,cost1);
				if(cost1<cost)
				{
					cost=cost1;
					memcpy(path_min,path,sizeof(path));
					memcpy(arc_min,arc,sizeof(arc));
					isRev=false;
				}
			}
		}
	
//A
		if(minPathNcost(RG,Rstart_end,dist,arc,flag,path))
		{
			k=1;
			cost1=calCost(RG,Rstart_end[1],path,arc);
			//printf("cost=%d, cost1=%d\n",cost,cost1);
			if(cost1<cost)
			{
				cost=cost1;
				memcpy(path_min,path,sizeof(path));
				memcpy(arc_min,arc,sizeof(arc));
				isRev=true;
			}
		}
		
		if(minPathNcost(G,start_end,dist,arc,flag,path))
		{
			k=1;
			cost1=calCost(G,start_end[1],path,arc);
			//printf("cost=%d, cost1=%d\n",cost,cost1);
			if(cost1<cost)
			{
				cost=cost1;
				memcpy(path_min,path,sizeof(path));
				memcpy(arc_min,arc,sizeof(arc));
				isRev=false;
			}
		}
		
		for(int i=0;i<start_end[2];i++)
		{
			//printf("%d , %d\n",i,ND[i].v );
			//printf("%d___%d\n", i,start_end[i]);
			if(minPathMidstNcost(G,RG,start_end,unvoid[i],dist,arc,flag,path,unvoid))
			{
				k=1;
				cost1=calCost(G,start_end[1],path,arc);
				//printf("cost=%d, cost1=%d\n",cost,cost1);
				if(cost1<cost)
				{
					cost=cost1;
					memcpy(path_min,path,sizeof(path));
					memcpy(arc_min,arc,sizeof(arc));
					isRev=false;
				}
			}
		}


//B
	//float pare[14][3]={{2,1,1},{-0.919,1.6,2.58},{0.23,1,1},{-0.3,1,1},{0.6,-0.1,0.9},{2,-0.5,0},{0.2,0.5,0},{0.11,0,-0.1},{0.41,0.3,0.1},{0.1,2,5},{-0.919,1.5,-0.68},{0.919,1.6,-1.58},{2.11,-1.4,0.8},{0.01,0.3,1.54}};
		float pare[13][3]={{2,1,1},{-0.919,1.6,2.58},{0.23,1,1},{-0.3,1,1},{0.6,-0.1,0.9},{2,-0.5,0},{0.2,0.5,0},{0.11,0,-0.1},{0.41,0.3,0.1},{0.1,2,5},{-0.919,1.5,-0.68},{2.11,-1.4,0.8},{0.01,0.3,1.54}};

		//int k=0;
		for(int i=0;i<13;i++)
		{
			updateNCostB(G,pare[i]);
			updateNCostB(RG,pare[i]);
			if(minPathNcost(RG,Rstart_end,dist,arc,flag,path))
			{
				k=1;
				cost1=calCost(RG,Rstart_end[1],path,arc);
				//printf("cost=%d, cost1=%d\n",cost,cost1);
				if(cost1<cost)
				{
					cost=cost1;
					memcpy(path_min,path,sizeof(path));
					memcpy(arc_min,arc,sizeof(arc));
					isRev=true;
				}
			}
			
			if(minPathNcost(G,start_end,dist,arc,flag,path))
			{
				k=1;
				cost1=calCost(G,start_end[1],path,arc);
				//printf("cost=%d, cost1=%d\n",cost,cost1);
				if(cost1<cost)
				{
					cost=cost1;
					memcpy(path_min,path,sizeof(path));
					memcpy(arc_min,arc,sizeof(arc));
					isRev=false;
				}
			}
			
			for(int i=0;i<start_end[2];i++)
			{
				//printf("%d , %d\n",i,ND[i].v );
				//printf("%d___%d\n", i,start_end[i]);
				if(minPathMidstNcost(G,RG,start_end,unvoid[i],dist,arc,flag,path,unvoid))
				{
					k=1;
					cost1=calCost(G,start_end[1],path,arc);
					//printf("cost=%d, cost1=%d\n",cost,cost1);
					if(cost1<cost)
					{
						cost=cost1;
						memcpy(path_min,path,sizeof(path));
						memcpy(arc_min,arc,sizeof(arc));
						isRev=false;
					}
				}
			}
		}


//C

	
		updateNCostC(G);
		updateNCostC(RG);
		if(minPathNcost(RG,Rstart_end,dist,arc,flag,path))
		{
			k=1;
			cost1=calCost(RG,Rstart_end[1],path,arc);
			//printf("cost=%d, cost1=%d\n",cost,cost1);
			if(cost1<cost)
			{
				cost=cost1;
				memcpy(path_min,path,sizeof(path));
				memcpy(arc_min,arc,sizeof(arc));
				isRev=true;
			}
		}
		
		if(minPathNcost(G,start_end,dist,arc,flag,path))
		{
			k=1;
			cost1=calCost(G,start_end[1],path,arc);
			//printf("cost=%d, cost1=%d\n",cost,cost1);
			if(cost1<cost)
			{
				cost=cost1;
				memcpy(path_min,path,sizeof(path));
				memcpy(arc_min,arc,sizeof(arc));
				isRev=false;
			}
		}
		
		for(int i=0;i<start_end[2];i++)
		{
			//printf("%d , %d\n",i,ND[i].v );
			//printf("%d___%d\n", i,start_end[i]);
			if(minPathMidstNcost(G,RG,start_end,unvoid[i],dist,arc,flag,path,unvoid))
			{
				k=1;
				cost1=calCost(G,start_end[1],path,arc);
				//printf("cost=%d, cost1=%d\n",cost,cost1);
				if(cost1<cost)
				{
					cost=cost1;
					memcpy(path_min,path,sizeof(path));
					memcpy(arc_min,arc,sizeof(arc));
					isRev=false;
				}
			}
		}
		
//D
	//float pare[12][3]={{2,1,1},{0.8,1,1},{0.6,1,0.9},{2,0.5,0},{1,0.5,0},{0.11,0,0.1},{0.11,0,0.4},{0.1,5,5},{-0.919,0.5,0.68},{-0.919,1.6,2.58},{2.11,1,0.8},{0.11,3,1.54}};

	//int k=0;
		for(int i=0;i<13;i++)
		{
			updateNCostD(G,pare[i]);
			updateNCostD(RG,pare[i]);
			if(minPathNcost(RG,Rstart_end,dist,arc,flag,path))
			{
				k=1;
				cost1=calCost(RG,Rstart_end[1],path,arc);
				//printf("cost=%d, cost1=%d\n",cost,cost1);
				if(cost1<cost)
				{
					cost=cost1;
					memcpy(path_min,path,sizeof(path));
					memcpy(arc_min,arc,sizeof(arc));
					isRev=true;
				}
			}
			
			if(minPathNcost(G,start_end,dist,arc,flag,path))
			{
				k=1;
				cost1=calCost(G,start_end[1],path,arc);
				//printf("cost=%d, cost1=%d\n",cost,cost1);
				if(cost1<cost)
				{
					cost=cost1;
					memcpy(path_min,path,sizeof(path));
					memcpy(arc_min,arc,sizeof(arc));
					isRev=false;
				}
			}
			
			for(int i=0;i<start_end[2];i++)
			{
				//printf("%d , %d\n",i,ND[i].v );
				//printf("%d___%d\n", i,start_end[i]);
				if(minPathMidstNcost(G,RG,start_end,unvoid[i],dist,arc,flag,path,unvoid))
				{
					k=1;
					cost1=calCost(G,start_end[1],path,arc);
					//printf("cost=%d, cost1=%d\n",cost,cost1);
					if(cost1<cost)
					{
						cost=cost1;
						memcpy(path_min,path,sizeof(path));
						memcpy(arc_min,arc,sizeof(arc));
						isRev=false;
					}
				}
			}
		}
	}
//顶点大于300直接用E算法
//E
	srand((int)time(0));
	//int k=0;
	do{
	
		updateNCostE(G);
		updateNCostE(RG);

		
		if(minPathNcost(RG,Rstart_end,dist,arc,flag,path))
		{
			k=1;
			cost1=calCost(RG,Rstart_end[1],path,arc);
			//printf("cost=%d, cost1=%d\n",cost,cost1);
			if(cost1<cost)
			{
				cost=cost1;
				memcpy(path_min,path,sizeof(path));
				memcpy(arc_min,arc,sizeof(arc));
				isRev=true;
			}
		}
		
		if(minPathNcost(G,start_end,dist,arc,flag,path))
		{
			k=1;
			cost1=calCost(G,start_end[1],path,arc);
			//printf("cost=%d, cost1=%d\n",cost,cost1);
			if(cost1<cost)
			{
				cost=cost1;
				memcpy(path_min,path,sizeof(path));
				memcpy(arc_min,arc,sizeof(arc));
				isRev=false;
			}
		}
		
		for(int i=0;i<start_end[2];i++)
		{
			//printf("%d , %d\n",i,ND[i].v );
			//printf("%d___%d\n", i,start_end[i]);
			if(minPathMidstNcost(G,RG,start_end,unvoid[i],dist,arc,flag,path,unvoid))
			{
				k=1;
				cost1=calCost(G,start_end[1],path,arc);
				//printf("cost=%d, cost1=%d\n",cost,cost1);
				if(cost1<cost)
				{
					cost=cost1;
					memcpy(path_min,path,sizeof(path));
					memcpy(arc_min,arc,sizeof(arc));
					isRev=false;
				}
			}
		}


	
	    if (minCost > cost)
		{
			minCost = cost;
			printf("总权值:,%.2f\n",cost);
			printf("总权值:,%.18f\n",abc);

		}

		

	}while(++iBLTest < 60);//150,200



	if(k==0)
	{
		return;
	}

/*------------------------------------------------------整理数据，准备输出--------------------------------*/
	int nn=-1;
	OrGraph *R;
	if(isRev)
	{
		nn=Rstart_end[1];//终点
		R=RG;
	}
	else{
		nn=start_end[1];//终点
		R=G;
	}
	
	int i=0;
	int result[R->vexNum];
	/**************用于测试与分析，最后可以不要的******************/
	
	/*int cost=0;
	int myArcId;*/
	int resultNode[R->vexNum];
	resultNode[i]=nn;
	/**/
	/**************************************************************/
	
	while(nn!=path_min[nn]&&nn>=0)
	{
		
		//printf("这是%d到%d---------\n",arc[nn],nn);
		result[i++]=arc_min[nn];//arc[nn]为path[nn]到nn的弧id
		resultNode[i]=path_min[nn];//临时记录
		/*myArcId=arc[nn];//临时记录
		*/
		//result[i++]=findArc(G,path[nn],nn);
		//printf("re[%d]=%d\n",i,result1[i] );
		nn=path_min[nn];
		//由于记录弧是从出发点后面一个节点开始的所以，还有由于记录弧时是从邻接表中找，所以要从上一个节点找
		/*cost=cost+findArcCost(R,nn,myArcId);
		*/
	}


/*****************************************************输出相关******************************************--测试--*/
	/*printArr(unvoid,start_end[2],"必经点");
	printf("总权值:,%.2f\n",cost);
	if(isRev){
		printf("起始点:,%d,%d\n",start_end[1],start_end[0]);
		printf("经过点:,");
		for(int k=0;k<=i;k++)
		{
			printf("%d,",resultNode[k]);
		}
		printf("\n");
	}
	else{
		printf("起始点:,%d,%d\n",start_end[0],start_end[1]);
		printf("经过点:,");
		for(int k=i;k>=0;k--)
		{
			printf("%d,",resultNode[k]);
		}
		printf("\n");
		printf("点入度:,");
		for(int k=i;k>=0;k--)
		{
			printf("%d,",G->clist[resultNode[k]].inDegree);
		}
		printf("\n");
		printf("点出度:,");
		for(int k=i;k>=0;k--)
		{
			printf("%d,",G->clist[resultNode[k]].outDegree);
		}
		printf("\n");
	}
	
	printf("总节点数:,%d\n",R->vexNum);
	printf("总边数:,%d\n",edge_num);
	printf("必经节点数:,%d\n",start_end[2]);
	*/


/********************************************************************************************/
	printf("顶点数%d\n", G->vexNum);
	if(isRev)
	{
		for(int j=0;j<i;j++)
		{
			record_result(result[j]);
		}	
	}
	else{
		for(int j=i-1;j>=0;j--)
		{
			record_result(result[j]);
		}	
	}
}

void createCNDArr(OrGraph *G,NodeDegree *nd,int num ,int unvoid[])
{
	//NodeDegree *nd=(NodeDegree *)calloc(num,sizeof(NodeDegree));//用动态分配不起作用不知为何，前面要加打印才行
	//静态分配
	//NodeDegree nd[num];
	//memset(nd,0,sizeof(nd));
	for(int i; i<num; i++)
	{
		nd[i].v=unvoid[i];
		nd[i].outDegree=G->clist[unvoid[i]].outDegree;
		nd[i].inDegree=G->clist[unvoid[i]].inDegree;
	}
	//return nd;
}
void redixSort(NodeDegree *ND,int num,int sortPosition){
	const int radix=10;//基数
	int count[radix]={0};//用0赋值所有
	int k=0;
	//int bucket[start_end[2]];
	NodeDegree bucket[num];
	//inDegree排序
	if(sortPosition==1)
	{

		for(int i=0;i<2;i++)
		{
			//2对应的是数字位的多少，这里数字小于100,所以用第一位与第二位分别排就行了
			memset(count,0,sizeof(count));
			for(int j=0;j<num;j++)
			{
				++count[getDigit(ND[j].inDegree,i)];//统计各个桶的将要获得元素的个数
			}
			for(int j=1;j<radix;j++)
			{
				count[j]=count[j]+count[j-1];//count[j]表示第j个桶的右边界
			}
			//将数据依次装入桶中
			//这里从右往左扫描，因为这是用count[j]表示第j个桶的右边界，其实它的存储空间在左边。
			//所以每次都要递减的存，即把大的存在高位，把小的存在低位。倒出的时候从左往右，然后承递增的方式
			for(int j=num-1;j>=0;j--)
			{
				k=getDigit(ND[j].inDegree,i);
				bucket[--count[k]]=ND[j];//装入对应桶中，相应桶的容量减1
			}
			for(int j=0;j<num;j++)
			{
				ND[j]=bucket[j];
			}
			//ND[0]=bucket[0];
			
		}
	}
	else
	{
		for(int i=0;i<2;i++)
		{
			//2对应的是数字位的多少，这里数字小于100,所以用第一位与第二位分别排就行了
			memset(count,0,sizeof(count));
			for(int j=0;j<num;j++)
			{
				++count[getDigit(ND[j].outDegree,i)];//统计各个桶的将要获得元素的个数
			}
			for(int j=1;j<radix;j++)
			{
				count[j]=count[j]+count[j-1];//count[j]表示第j个桶的右边界
			}
			//将数据依次装入桶中
			//这里从右往左扫描，因为这是用count[j]表示第j个桶的右边界，其实它的存储空间在左边。
			//所以每次都要递减的存，即把大的存在高位，把小的存在低位。倒出的时候从左往右，然后承递增的方式
			for(int j=num-1;j>=0;j--)
			{
				k=getDigit(ND[j].outDegree,i);
				bucket[--count[k]]=ND[j];//装入对应桶中，相应桶的容量减1
			}
			for(int j=0;j<num;j++)
			{
				ND[j]=bucket[j];
			}
			
		}
	}
}
int getDigit(int num, int i){
	const int unit[2]={1,10};
	return (num/unit[i])%10;
}

void cut(OrGraph *G1,OrGraph *G2,int unvoid[],int start_end[],bool *mark1,bool *mark2)
{
	//还需要初始化标记
	//ArcNode *tmp1=NULL,*tmp2=NULL,*tmp3=NULL;
	//int tmpv;
	
	//cutNeighborInD(RG,G,start_end[0],mark);
	//cutNeighborOutD(RG,G,start_end[1],mark);
	cutNeighborInD(G1,G2,start_end[1],mark1,start_end[0]);//结束节点入度为1的减枝
	cutNeighborOutD(G1,G2,start_end[0],mark2,start_end[1]);//开始节点出度为1的减枝
	//memset(mark,false,sizeof(mark));
	for(int i=0;i<start_end[2];i++)//还可以加功能把初始点入度为0，终点出度为零
	{
		//邻接表通过逆邻接表找到前驱使入度为1的点的前驱的出度也为1，至于要把出度为1的后继的入度也改为1，就要搜索了
		//相互影响的，所以一个个切吧
		//cutNeighborInD(RG,G,unvoid[i],mark);
		//cutNeighborOutD(RG,G,unvoid[i],mark);
		cutNeighborInD(G1,G2,unvoid[i],mark1,start_end[0]);//剪去邻接表中点unvoid[i]的前驱的出度
		cutNeighborOutD(G1,G2,unvoid[i],mark2,start_end[1]);//剪去邻接表中点unvoid[i]的后继的入度
		
	}

}
//入度是向上剪枝，出度是向下剪枝
void cutNeighborInD(OrGraph *G1,OrGraph *G2,int v,bool *mark1,int beg)
{
	//该点的入度为1则把其前驱结点的其它出度删去，G1，G2互为逆邻接表
	
	if(G1->clist[v].inDegree==1&&!mark1[v])
	{
		ArcNode *tmp1,*tmp2;//静态局部变量，只在这个函数中定义一次。
		mark1[v]=true;
		int vt;
		tmp1=G2->clist[v].firstLink;//该点u逆邻上的第一条弧,其连接的就是v的前驱
		tmp2=G1->clist[tmp1->headVex].firstLink;//上面弧连接的点的弧
		while(tmp2&&tmp2->nextLink && tmp2->nextLink->headVex!=v)
		{
			--G1->clist[tmp2->nextLink->headVex].inDegree;
			vt=tmp2->nextLink->headVex;
			tmp2->nextLink=tmp2->nextLink->nextLink;

			if(G1->clist[vt].inDegree==1 && G1->clist[vt].key)//这里可以不用前面那个度判断，这样加上只是为了避免进入函数而降低执行速度
			{
				cutNeighborInD(G1,G2,vt,mark1,beg);
			}
			else if(G1->clist[vt].inDegree==0 && vt!=beg)
			{
				removeInZeroNode(G1,G2,vt,mark1,beg);
			}
			
			tmp2=tmp2->nextLink;
		}

		tmp2=G1->clist[tmp1->headVex].firstLink;
		if(tmp2 && tmp2->headVex!=v)
		{
			
			--G1->clist[tmp2->headVex].inDegree;
			G1->clist[tmp1->headVex].firstLink=tmp2->nextLink;
			if(G1->clist[tmp2->headVex].inDegree==1 && G1->clist[tmp2->headVex].key)
			{
				cutNeighborInD(G1,G2,tmp2->headVex,mark1,beg);
			}
			else if(G1->clist[tmp2->headVex].inDegree==0 && tmp2->headVex!=beg)
			{
				removeInZeroNode(G1,G2,tmp2->headVex,mark1,beg);
			}
			
		}
		//tmp2->nextLink=NULL;
		//G1->clist[tmp1->headVex].firstLink=tmp2;
		G1->clist[tmp1->headVex].outDegree=1;

		//如果不是必经则递归删除，因为是必经的话会在删除的范围的，这里避免重复操作。
		//v=tmp1->headVex;//记录其前驱节点的节点ID,方便递归删除,当然这里删除是因为它不是必经节点，只是因为必经的前驱只有它，所以它和必经其实是等价的
		//由于这里的tmp1->headVex剪枝不影响必经节点的入度，而必经节点最终都要遍历的
		//考虑到减支对其它节点的影响，这里是不是还要补充一点，如果减去的是另一个必经的入度，那么就要调整该点的入度，查看是否为1然后减枝。
		if(!G1->clist[tmp1->headVex].key)
		{cutNeighborInD(G1,G2,tmp1->headVex,mark1,beg);}
	}	
}
void cutNeighborOutD(OrGraph *G1,OrGraph *G2,int v,bool *mark2,int end)
{
	
	if(G1->clist[v].outDegree==1&&!mark2[v])
	{
		ArcNode *tmp1,*tmp2,*tmp3;
		mark2[v]=true;
		//printf("%d_%d\n", v,G1->clist[v].outDegree);
		tmp1=G1->clist[v].firstLink;//后继

		tmp2=G2->clist[tmp1->headVex].firstLink;//后继的逆邻接表

		while(tmp2)//后继的逆邻接表减枝，因为unvoid[i]为必经所以它的唯一后继必须经过它，在逆邻接表中就是它的前驱必经过它，所以把逆邻接表中的其它出去的分支去掉
		{
			if(tmp2->headVex!=v)//这里要除去为必经点的那个头节点
			{
				tmp3=G1->clist[tmp2->headVex].firstLink;//取得指向出度为1的后继的其它前驱节点
				
				//先while把边中的指向出度为1的后继的其它前驱去掉，再看看第一条边，即与头节点相连的那条边，如果是的话，把后面的边连接到头节点
				//剪了之后导致其它节点的出度可能为1，但是这不重要，因为其它节点可能不是必经节点。如果是必经节点的话，那那还是要继续剪，有没有意义呢，可能有的，不防试试
				while(tmp3)
				{
					if(tmp3->nextLink && tmp3->nextLink->headVex==tmp1->headVex)
					{
						tmp3->nextLink=tmp3->nextLink->nextLink;
						//break;如果有多条一个点同时指向该唯一后继的前驱节点的话就要继续找而不用break;
						--G1->clist[tmp2->headVex].outDegree;
					}
					tmp3=tmp3->nextLink;
				}

				//再取一次，检查与头节点相连的第一条边
				tmp3=G1->clist[tmp2->headVex].firstLink;//取得指向出度为1的后继的其它前驱节点
				if(tmp3 && tmp3->headVex==tmp1->headVex)//把必经点唯一后继的其它前驱指向该节点边给去掉,为什么要单独拿出来，因为有一个点的头节点，如查第一条边就是那么就得把下一条边连接到头节点
				{
					G1->clist[tmp2->headVex].firstLink=tmp3->nextLink;
					--G1->clist[tmp2->headVex].outDegree;
				}
				//如果为必经，若剪了之后出度变为1则继续剪
				if(G1->clist[tmp2->headVex].outDegree==1 && G1->clist[tmp2->headVex].key)
				{
					cutNeighborOutD(G1,G2,tmp2->headVex,mark2,end);
				}
				else if(G1->clist[tmp2->headVex].outDegree==0 && tmp2->headVex!=end)
				{
					removeOutZeroNode(G1,G2,tmp2->headVex,mark2,end);
				}
				
			}
			tmp2=tmp2->nextLink;
			
		}

		//剪v的后继节点的入度，前不影响其后继节点的出度，所以这里不用递归，如果其出度为1的话会在剪的范围内
		//但是如果不是必经则在剪的范围，因为当必经节点的唯一后继节点的出度为1时，此时其和必经是一样的，相当于必经只有一条出度
		if(!G1->clist[tmp1->headVex].key)
		{cutNeighborOutD(G1,G2,tmp1->headVex,mark2,end);}
	}
	
}
//去掉度为零的点，除了终点和起点
void removeZero(OrGraph *G1,OrGraph *G2, int start_end[],bool *mark1,bool *mark2)
{
	//去除每个出度为零的点
	for(int i=0;i < G1->vexNum;i++)
	{
		//其实由于减枝先后其实是相互影响的，管他的影响不大
		//removeOutZeroNode(RG,G,i,start_end[1]);
		removeInZeroNode(G1,G2,i,mark1,start_end[0]);
		removeOutZeroNode(G1,G2,i,mark2,start_end[1]);
	}
}
void removeOutZeroNode(OrGraph *G1,OrGraph *G2,int v,bool *mark2,int end)
{
	
	//除去开始与结束节点的出度为零的点来减小网络，删去无效的点，使其它点的无效边减少，方便减枝
	//为什么要除去起终点呢，当然要去除终点
	if(G1->clist[v].outDegree==0 && v!=end)
	{
		ArcNode *tmp1,*tmp2;

		tmp1=G2->clist[v].firstLink;

		while(tmp1)
		{	
			tmp2=G1->clist[tmp1->headVex].firstLink;
			while(tmp2)
			{
				if(tmp2->nextLink && tmp2->nextLink->headVex==v)
				{
					tmp2->nextLink=tmp2->nextLink->nextLink;
					--G1->clist[tmp1->headVex].outDegree;
				}
				tmp2=tmp2->nextLink;
			}
			tmp2=G1->clist[tmp1->headVex].firstLink;

			if(tmp2 && tmp2->headVex==v)
			{

				//printf("%d,%d,%d\n",tmp1->headVex,tmp2->headVex,G1->clist[tmp1->headVex].outDegree);
				G1->clist[tmp1->headVex].firstLink=tmp2->nextLink;
				--G1->clist[tmp1->headVex].outDegree;
			}
			//出错的原因可能是在邻接表中删除了但在逆邻接表中还有这个，但是有判断啊怎么错了
			//最终出错原因是用的静态局部变量不能用在递归

			if(G1->clist[tmp1->headVex].outDegree==0)
			{
				removeOutZeroNode(G1,G2,tmp1->headVex,mark2,end);
			}
			else if(G1->clist[tmp1->headVex].outDegree==1 && G1->clist[tmp1->headVex].key)
			{
				cutNeighborOutD(G1,G2,tmp1->headVex,mark2,end);
			}
			tmp1=tmp1->nextLink;
		}
		G1->clist[v].inDegree=0;//出度为零的点入度清为零
	}

}

//把入度为零的点去掉，没有意义因为在邻接表中只是连接出度
//想了想还是有意义的，因为影响了别的点的度，而度的大小是影响选择的
void removeInZeroNode(OrGraph *G1,OrGraph *G2,int v,bool *mark1,int beg)
{
	
	if(G1->clist[v].inDegree==0 && v!=beg)//排除是起点的点
	{
		//removeEndNode(G1,i);//入度为零的就去除其出度，和终点去除其出度是一样的道理。
		ArcNode *tmp1;
		int vt;//这里用于临时存放顶点
		tmp1=G1->clist[v].firstLink;//获得终点节点的后继

		while(tmp1&&tmp1->nextLink)
		{
			--G1->clist[tmp1->nextLink->headVex].inDegree;
			vt=tmp1->nextLink->headVex;
			tmp1->nextLink=tmp1->nextLink->nextLink;
			
			if(G1->clist[vt].inDegree==0)
			{
				removeInZeroNode(G1,G2,vt,mark1,beg);
			}
			else if(G1->clist[vt].inDegree==1 && G1->clist[vt].key)
			{
				cutNeighborInD(G1,G2,vt,mark1,beg);
			}
			tmp1=tmp1->nextLink;
		}
		tmp1=G1->clist[v].firstLink;//获得终点节点的后继
		if(tmp1)
		{
			--G1->clist[tmp1->headVex].inDegree;
			G1->clist[v].firstLink=tmp1->nextLink;

			if(G1->clist[tmp1->headVex].inDegree==0)
			{
				removeInZeroNode(G1,G2,tmp1->headVex,mark1,beg);
			}
			else if(G1->clist[tmp1->headVex].inDegree==1 && G1->clist[tmp1->headVex].key)
			{
				cutNeighborInD(G1,G2,tmp1->headVex,mark1,beg);
			}
			
		}
		G1->clist[v].outDegree=0;//入度为零的点，出度清为零
	}
	
	
}

//再看看两个邻接表依赖问题
//去除开始节点的前驱，使之前驱的度减一在之后的去度可能有帮助
void removeBeginNode(OrGraph *G1, OrGraph *G2,int begin)
{
	//操作的是G1，G2是作为参考的
	ArcNode *tmp1,*tmp2;
	tmp1=G2->clist[begin].firstLink;//开始节点的邻接边
	while(tmp1)//寻找开始节点前驱
	{
		tmp2=G1->clist[tmp1->headVex].firstLink;//寻找开始节点前驱的后继
		while(tmp2&&tmp2->nextLink)
		{
			if(tmp2->nextLink->headVex==begin)//后继等于开始节点的则去除,这里这样子是因为有个头节点，其链域不一样，下面if专家处理头节点下的第一个节点相同情况下
			{
				tmp2->nextLink=tmp2->nextLink->nextLink;
				--G1->clist[tmp1->headVex].outDegree;
			}
			tmp2=tmp2->nextLink;
		}
		tmp2=G1->clist[tmp1->headVex].firstLink;//寻找开始节点前驱的后继
		if(tmp2 && tmp2->headVex==begin)
		{
			G1->clist[tmp1->headVex].firstLink=tmp2->nextLink;
			--G1->clist[tmp1->headVex].outDegree;
		}
		
		tmp1=tmp1->nextLink;
	}
	G1->clist[begin].inDegree=0;//起点，入度清为零
}
void removeEndNode(OrGraph *G1,int end)
{
	ArcNode *tmp1;
	tmp1=G1->clist[end].firstLink;//获得终点节点的后继

	while(tmp1&&tmp1->nextLink)
	{
		--G1->clist[tmp1->nextLink->headVex].inDegree;
		tmp1->nextLink=tmp1->nextLink->nextLink;
		tmp1=tmp1->nextLink;
	}
	tmp1=G1->clist[end].firstLink;//获得终点节点的后继
	if(tmp1)
	{
		--G1->clist[tmp1->headVex].inDegree;
		G1->clist[end].firstLink=tmp1->nextLink;
	}
	G1->clist[end].outDegree=0;//终点，出度清为零
}

void removeBENode(OrGraph *G1,OrGraph *G2,int start_end[])//去除开始点的前驱和结束点的后继并调整度
{
	removeBeginNode(G1,G2,start_end[0]);
	removeEndNode(G1,start_end[1]);
}

//计算权值
float calCost(OrGraph *G,int end,int path[],int arc[])
{
	int nn;
	float cost=0;
	int myArcId;
	nn=end;
	while(nn!=path[nn]&&nn>=0)
	{

		myArcId=arc[nn];//临时记录
		nn=path[nn];
		//由于记录弧是从出发点后面一个节点开始的所以，还有由于记录弧时是从邻接表中找，所以要从上一个节点找
		cost=cost+findArcCost(G,nn,myArcId);
	}
	return cost;
}
//输出函数
void outputALLDegree(OrGraph *G)
{
	printf("ID 入度 出度\n");
	for(int i=0;i<G->vexNum;i++)
	{
		outputDegree(G,i);
	}
}
void outputDegree(OrGraph *G,int v)
{
	printf("%d %d %d\n", v,G->clist[v].inDegree,G->clist[v].outDegree);
}
void outputCriDegree(OrGraph *G,int unvoid[],int start_end[])
{
	printf("ID 入度 出度\n");
	outputDegree(G,start_end[0]);
	outputDegree(G,start_end[1]);
	for(int i=0;i<start_end[2];++i)
	{
		outputDegree(G,unvoid[i]);
	}
}
//按行输出
void outputAllDegree_Arr(OrGraph *G)
{
	printf("全部ID:,");
	for(int i=0;i<G->vexNum;i++)
	{
		printf("%d,", i);
	}
	printf("\n入度:,");
	for(int i=0;i<G->vexNum;i++)
	{
		printf("%d,", G->clist[i].inDegree);
	}
	printf("\n出度:,");
	for(int i=0;i<G->vexNum;i++)
	{
		printf("%d,", G->clist[i].outDegree);
	}
	printf("\n");
}
void outputCriDegree_Arr(OrGraph *G,int unvoid[],int start_end[])
{
	printf("必经ID:,");
	for(int i=0;i<start_end[2];i++)
	{
		printf("%d,", unvoid[i]);
	}
	printf("\n入度:,");
	for(int i=0;i<start_end[2];i++)
	{
		printf("%d,", G->clist[unvoid[i]].inDegree);
	}
	printf("\n出度:,");
	for(int i=0;i<start_end[2];i++)
	{
		printf("%d,", G->clist[unvoid[i]].outDegree);
	}
	printf("\n");
}
/**********************算法*******************************/

void updateNCostA(OrGraph *G)
{
	ArcNode *p;
	float ave=calNodeInDeAverage(G);
	float dev=calNodeInDeStdDe(G,ave);

	//float aveO=calNodeOutDeAverage(G);
	//float devO=calNodeOutDeStdDe(G,aveO);

	float inDeStd,outDeStd;
	float inDe;//,outDe;
	for(int i=0;i<G->vexNum;i++)
	{
		p=G->clist[i].firstLink;
		while(p)
		{
			/*
			inDe=G->clist[p->headVex].inDegree<16?G->clist[p->headVex].inDegree:16;
			outDe=G->clist[p->headVex].outDegree;
			inDeStd=(inDe-ave)/dev;
			outDeStd=(outDe-aveO)/devO;
			p->Ncost=10+0.11*outDeStd + 0*inDeStd + 0.1*(p->cost-10.5)/5.5;//p->Ncost=outDeStd * (inDestd+(20+p->cost-21)/5.5);标准化算耗费，入度越大耗费越大，出度越大耗费越大，我们是要先选择入度和出度小的点来走，标准化后有负的转化为正的
			p=p->nextLink;*/
			inDe=G->clist[p->headVex].inDegree<16?G->clist[p->headVex].inDegree:16;
			inDeStd=(16+inDe-2*ave)/dev;
			outDeStd=G->clist[p->headVex].outDegree/16.0;
			p->Ncost=outDeStd +(inDeStd+(p->cost-1)/5.5);//p->Ncost=outDeStd * (inDestd+(20+p->cost-21)/5.5);标准化算耗费，入度越大耗费越大，出度越大耗费越大，我们是要先选择入度和出度小的点来走，标准化后有负的转化为正的
			p=p->nextLink;
		}
	}
	//printf("%.2f___%.2f\n",ave,dev);
}

void updateNCostB(OrGraph *G,float join[])
{
	ArcNode *p;
	float ave=calNodeInDeAverage(G);
	float dev=calNodeInDeStdDe(G,ave);

	float aveO=calNodeOutDeAverage(G);
	float devO=calNodeOutDeStdDe(G,aveO);

	float inDeStd,outDeStd;
	float inDe,outDe;
	for(int i=0;i<G->vexNum;i++)
	{
		p=G->clist[i].firstLink;
		while(p)
		{
			//弧的新权值是它连接的头节点的出度和入度以及它自己的权值的表达式值
			/*得分7.6第
			inDe=G->clist[p->headVex].inDegree<16?G->clist[p->headVex].inDegree:16;
			inDeStd=(16+inDe-2*ave)/dev;
			outDeStd=G->clist[p->headVex].outDegree/16.0;
			p->Ncost=outDeStd +(inDeStd+(p->cost-1)/5.5);//p->Ncost=outDeStd * (inDestd+(20+p->cost-21)/5.5);标准化算耗费，入度越大耗费越大，出度越大耗费越大，我们是要先选择入度和出度小的点来走，标准化后有负的转化为正的
			p=p->nextLink;
			*/
			/*//方案一，求出了7，不过其实得分不高80，这里是分别z-score标准化和移轴
			inDe=G->clist[p->headVex].inDegree<16?G->clist[p->headVex].inDegree:16;
			inDeStd=(16+inDe-2*ave)/dev;
			outDeStd=G->clist[p->headVex].outDegree/8.0;
			p->Ncost=1+outDeStd * (inDeStd+(p->cost-1)/5.5);//p->Ncost=outDeStd * (inDestd+(20+p->cost-21)/5.5);标准化算耗费，入度越大耗费越大，出度越大耗费越大，我们是要先选择入度和出度小的点来走，标准化后有负的转化为正的
			p=p->nextLink;
			*/
			//float pare[][]={{2,1,1},{0.8,1,1},{0.6,1,0.9},{2,0.5,0},{1,0.5,0},{0.11,0,0.1}}
			//方案二，分别标准化之和，各项系数为1，再整体移轴，这样子效果不好才62分，4，5都没有求出来更不用说14，15
			//p->Ncost=8+outDeStd + inDeStd + (p->cost-10.5)/5.5;
			//方案三，分别标准化之各，出度系数为2，其它系数为1。能求出7，4且4为满分，5比较低,其它不高，14，15没有出来
			//p->Ncost=8+2*outDeStd + inDeStd + (p->cost-10.5)/5.5;
			//方案四，1.5倍的权值，2倍出度效果同方案三p->Ncost=8+2*outDeStd + inDeStd + 1.5*(p->cost-10.5)/5.5;
			//方案五p->Ncost=10+0.8*outDeStd + inDeStd + (p->cost-10.5)/5.5;14求出来了，不过4，5没有求出，总体分数72还将就
			//方案6总分75第5个没求出,第14求出,有些分数比较低,p->Ncost=10+0.8*outDeStd + inDeStd + 0.9*(p->cost-10.5)/5.5;
			//方案7第5个没求出来76分比方案6稍好p->Ncost=10+0.6*outDeStd + inDeStd + 0.9*(p->cost-10.5)/5.5;
			//方案8，p->Ncost=10+0.5*outDeStd + inDeStd + 0.9*(p->cost-10.5)/5.5;这个不好没有7好67分
			//方案9，p->Ncost=10+0.6*outDeStd + inDeStd + 0.8*(p->cost-10.5)/5.5;第5个没解出来68
			//方案10，p->Ncost=10+0.6*outDeStd + inDeStd + (p->cost-10.5)/5.5;72没求出4，5求出了14
			//方案11，p->Ncost=10+2*outDeStd + inDeStd + 0.5*(p->cost-10.5)/5.5;71.8第5个没出,求出了14
			//方案12，p->Ncost=10+2*outDeStd + 0.5*inDeStd + 0*(p->cost-10.5)/5.5;第十五个出来了
			//方案13，p->Ncost=10+0*outDeStd + 0.5*inDeStd + 0*(p->cost-10.5)/5.5;第十五个出来了，比上一个差
			//方案14，p->Ncost=10+outDeStd + 0.5*inDeStd + 0*(p->cost-10.5)/5.5;可以同时求出第14与15并且都在91,其它case分比较低，第5个没出来，81
			//方案15，p->Ncost=10+outDeStd + 0*inDeStd + 0*(p->cost-10.5)/5.5;可以同时求出第14与15并且都在91，无法求出case5，分比上面低，78
			//方案16，p->Ncost=10+outDeStd + 0.5*inDeStd + 0.2*(p->cost-10.5)/5.5;74第5个出不来，第14个出来了
			//第5个64，p->Ncost=10+0.1*outDeStd + 0.2*inDeStd + 0.1*(p->cost-10.5)/5.5;
			//方案17，第五个出来了p->Ncost=10+0.11*outDeStd + 0*inDeStd + 0.1*(p->cost-10.5)/5.5;
			inDe=G->clist[p->headVex].inDegree<16?G->clist[p->headVex].inDegree:16;
			outDe=G->clist[p->headVex].outDegree;
			inDeStd=(inDe-ave)/dev;
			outDeStd=(outDe-aveO)/devO;
			p->Ncost=5+join[0]*outDeStd + join[1]*inDeStd + join[2]*(p->cost-10.5)/5.5;//p->Ncost=outDeStd * (inDestd+(20+p->cost-21)/5.5);标准化算耗费，入度越大耗费越大，出度越大耗费越大，我们是要先选择入度和出度小的点来走，标准化后有负的转化为正的
			p=p->nextLink;
		}
	}
	//printf("%.2f___%.2f\n",ave,dev);
}
void updateNCostC(OrGraph *G)
{
	ArcNode *p;
	float ave=calNodeInDeAverage(G);
	float dev=calNodeInDeStdDe(G,ave);

	float aveO=calNodeOutDeAverage(G);
	float devO=calNodeOutDeStdDe(G,aveO);

	float inDeStd,outDeStd;
	float inDe,outDe;
	for(int i=0;i<G->vexNum;i++)
	{
		p=G->clist[i].firstLink;
		while(p)
		{
			
			inDe=G->clist[p->headVex].inDegree<16?G->clist[p->headVex].inDegree:16;
			outDe=G->clist[p->headVex].outDegree;
			inDeStd=(inDe-ave)/dev;
			outDeStd=(outDe-aveO)/devO;
			p->Ncost=0.11*outDeStd + 3*inDeStd + 1.54*(2+(p->cost-10.5)/5.5);//p->Ncost=outDeStd * (inDestd+(20+p->cost-21)/5.5);标准化算耗费，入度越大耗费越大，出度越大耗费越大，我们是要先选择入度和出度小的点来走，标准化后有负的转化为正的
			p=p->nextLink;
		}
	}
	//printf("%.2f___%.2f\n",ave,dev);
}

void updateNCostD(OrGraph *G,float join[])
{
	ArcNode *p;
	float ave=calNodeInDeAverage(G);
	float dev=calNodeInDeStdDe(G,ave);

	float aveO=calNodeOutDeAverage(G);
	float devO=calNodeOutDeStdDe(G,aveO);

	float inDeStd,outDeStd;
	float inDe,outDe;
	for(int i=0;i<G->vexNum;i++)
	{
		p=G->clist[i].firstLink;
		while(p)
		{
			inDe=G->clist[p->headVex].inDegree<16?G->clist[p->headVex].inDegree:16;
			outDe=G->clist[p->headVex].outDegree;
			inDeStd=(inDe-ave)/dev;
			outDeStd=(outDe-aveO)/devO;
			p->Ncost=10+join[0]*outDeStd + join[1]*inDeStd + join[2]*(p->cost-10.5)/5.5;//p->Ncost=outDeStd * (inDestd+(20+p->cost-21)/5.5);标准化算耗费，入度越大耗费越大，出度越大耗费越大，我们是要先选择入度和出度小的点来走，标准化后有负的转化为正的
			p=p->nextLink;
		}
	}
	//printf("%.2f___%.2f\n",ave,dev);
}
void updateNCostE(OrGraph *G)
{
	ArcNode *p;
	float ave=calNodeInDeAverage(G);
	float dev=calNodeInDeStdDe(G,ave);

	float aveO=calNodeOutDeAverage(G);
	float devO=calNodeOutDeStdDe(G,aveO);

	float inDeStd,outDeStd;
	float inDe,outDe;
	abc = (rand()/(RAND_MAX+1.0));
	for(int i=0;i<G->vexNum;i++)
	{
		p=G->clist[i].firstLink;
		while(p)
		{
			
			inDe=G->clist[p->headVex].inDegree<16?G->clist[p->headVex].inDegree:16;
			outDe=G->clist[p->headVex].outDegree;
			inDeStd=(inDe-ave)/dev;
			outDeStd=(outDe-aveO)/devO;

			//abc = (rand()/(RAND_MAX+1.0));
			p->Ncost=p->cost+0.8*abc;
			//p->Ncost = inDe - outDe + p->cost - p->cost*sin(50*p->cost*3.14159/180)+abc;  // 199 (7)
			p=p->nextLink;
		}
	}
}
float calNodeInDeAverage(OrGraph *G)
{
	float totalInDe=0;
	for(int i=0;i<G->vexNum;i++)
	{
		totalInDe=totalInDe+G->clist[i].inDegree;
	}
	return totalInDe/G->vexNum;
}
float calNodeInDeStdDe(OrGraph *G,float ave)
{
	//float ave=calNodeInDeAverage(G);
	float tSqu=0;
	for(int i=0;i<G->vexNum;i++)
	{
		tSqu=tSqu + pow(G->clist[i].inDegree-ave,2);
	}
	return sqrt(tSqu/G->vexNum);
}


float calNodeOutDeAverage(OrGraph *G)
{
	float totalOutDe=0;
	for(int i=0;i<G->vexNum;i++)
	{
		totalOutDe=totalOutDe+G->clist[i].outDegree;
	}
	return totalOutDe/G->vexNum;
}
float calNodeOutDeStdDe(OrGraph *G,float aveO)
{
	//float ave=calNodeInDeAverage(G);
	float tSquO=0;
	for(int i=0;i<G->vexNum;i++)
	{
		tSquO=tSquO + pow(G->clist[i].outDegree-aveO,2);
	}
	return sqrt(tSquO/G->vexNum);
}


void testOutNcost(OrGraph *G)
{
	ArcNode *p;
	for(int i=0;i<G->vexNum;i++)
	{
		p=G->clist[i].firstLink;
		while(p)
		{
			printf("%d->%d, %.3f , %d\n", p->tailVex,p->headVex,p->Ncost,p->cost);
			p=p->nextLink;
		}

	}
}
